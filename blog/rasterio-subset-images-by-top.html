<!DOCTYPE html>
<html lang="en">
<head>
	<title>Rasterio: Subset Images By Top-Left Coordinates &amp; Dimensions</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Rasterio: Subset Images By Top-Left Coordinates & Dimensions...">
    <link rel="canonical" href="https://catatansoal.github.io/blog/rasterio-subset-images-by-top">
	<meta property="og:type" content="article">
	<meta property="og:title" content="Rasterio: Subset Images By Top-Left Coordinates &amp; Dimensions">
	<meta property="og:description" content="Rasterio: Subset Images By Top-Left Coordinates & Dimensions...">
	<meta property="og:url" content="https://catatansoal.github.io/blog/rasterio-subset-images-by-top">
	<meta property="og:site_name" content="Question Notes">
	<meta property="article:published_time" content="2025-08-06T21:17:56+00:00">
	<meta property="article:author" content="ADMIN">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="preload" as="script" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js">
    <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <link rel="preload" fetchpriority="high" as="image" href="https://tse4.mm.bing.net/th?q=Rasterio%3A%20How%20to%20Subset%20Georeferenced%20Images%20by%20Top-Left%20Coordinates%20and%20Dimensions">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style type="text/css">
    	:root{--primary-color:#3740ff;--text-color:#202124;--background-color:#ffffff;--gray-100:#f8f9fa;--gray-200:#e9ecef}*{margin:0;padding:0;box-sizing:border-box}body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;line-height:1.6;color:var(--text-color);background-color:var(--background-color)}.container{max-width:1200px;margin:0 auto;padding:0 1.5rem}.header{background-color:var(--background-color);border-bottom:1px solid var(--gray-200);position:sticky;top:0;z-index:100}.nav{padding:.5rem 0}.nav-container{display:flex;justify-content:space-between;align-items:center;gap:1rem}.nav-left{display:flex;align-items:center;flex-shrink:0}.logo{font-weight:700;color:var(--primary-color)}.blog-tag{margin-left:1rem;padding:.25rem .5rem;background-color:var(--gray-100);border-radius:4px;font-size:.875rem}.nav-search{flex-grow:1;max-width:300px}.search-form{position:relative;width:100%}.search-input{width:100%;padding:.5rem 2.5rem .5rem 1rem;border:1px solid var(--gray-200);border-radius:24px;font-size:.875rem;transition:all 0.2s}.search-input:focus{outline:none;border-color:var(--primary-color);box-shadow:0 0 0 2px rgb(55 64 255 / .1)}.search-button{position:absolute;right:.5rem;top:50%;transform:translateY(-50%);background:none;border:none;color:#5f6368;cursor:pointer;padding:.25rem;display:flex;align-items:center;justify-content:center}.search-button:hover{color:var(--primary-color)}.nav-toggle{display:none;background:none;border:none;cursor:pointer;padding:.5rem}.hamburger{display:block;position:relative;width:24px;height:2px;background:var(--text-color);transition:all 0.3s}.hamburger::before,.hamburger::after{content:'';position:absolute;width:24px;height:2px;background:var(--text-color);transition:all 0.3s}.hamburger::before{top:-6px}.hamburger::after{bottom:-6px}.nav-toggle-active .hamburger{background:#fff0}.nav-toggle-active .hamburger::before{transform:rotate(45deg);top:0}.nav-toggle-active .hamburger::after{transform:rotate(-45deg);bottom:0}.nav-list{display:flex;list-style:none;gap:2rem}.nav-link{color:var(--text-color);text-decoration:none;font-size:.9rem;transition:color 0.2s}.nav-link:hover{color:var(--primary-color)}.article-header{padding:2rem 0;background-color:var(--gray-100)}.article-layout{display:grid;grid-template-columns:1fr 350px;gap:3rem;padding:1rem 0;align-items: start}h1,h2,h3,h4,h5,h6{font-family:"Crimson Text","Times New Roman",Times,serif}h1{font-size:2.5rem;line-height:1.2;margin-bottom:1rem}.meta{color:#5f6368;font-size:.875rem;display:flex;align-items:center;gap:1rem;flex-wrap:wrap}.view-count{display:inline-flex;align-items:center;gap:.25rem}.view-count svg{color:#5f6368}.content{min-width:0;border-bottom:1px solid #dddddd5e;margin-top:1rem;white-space:pre-line !important;overflow-wrap:break-word;overflow-x:auto;word-break:break-word}.lead{font-size:1.25rem;color:#5f6368;margin-bottom:2rem}h2,h3,h4,h5,h6{font-size:1.75rem;margin:1rem 0 1rem}p,pre,ol,ul>li{margin-bottom:1rem;font-family:"Newsreader",serif;font-optical-sizing:auto;font-style:normal;font-size:1.3rem;text-align: justify;}p>code{font-size:1rem;font-weight:700;padding:.1rem .3rem .1rem .3rem;background:#0000000f;color:#000;border-radius:5px}hr{margin:1rem 0 1rem 0}.code-example{background-color:var(--gray-100);padding:1.5rem;border-radius:8px;margin:1.5rem 0;overflow-x:auto}code{font-family:'Roboto Mono',monospace;font-size:.875rem}ul{margin:.2rem 0;padding-left:1.5rem}.related-posts{background-color:var(--gray-100);padding:1.5rem;border-radius:8px;position:sticky;top:5rem}.related-posts-title,.newpost-posts-list{font-size:1.75rem;margin:0 0 1rem}.related-posts-list{display:flex;flex-direction:column;gap:.5rem}.related-post,.newpost-post{border-bottom:1px solid #ddd;padding-bottom:10px;margin-bottom:10px}.related-post:last-child,.newpost-post:last-child{padding-bottom:0;border-bottom:none}.related-post-title,.newpost-post-title{font-size:1.2rem;margin:0 0 .1rem;font-family:"Newsreader",serif;font-optical-sizing:auto;font-style:normal;display: -webkit-box;-webkit-line-clamp: 3;-webkit-box-orient: vertical;overflow: hidden;}.related-post-title a,.newpost-post-title a{color:var(--text-color);text-decoration:none;transition:color 0.2s}.related-post-title a:hover,.newpost-post-title a:hover{color:var(--primary-color)}.related-post time{font-size:.875rem;color:#5f6368}.footer{background-color:var(--gray-100);padding:2rem 0;margin-top:4rem;color:#5f6368;font-size:.875rem}.nav-menu>ul>li{margin-bottom:0}@media (max-width:1024px){.container{max-width:800px}.article-layout{grid-template-columns:1fr;gap:2rem}.related-posts{position:static}}@media (max-width:768px){.nav-container{flex-wrap:wrap}.nav-search{order:3;max-width:none;width:100%;margin-top:.1rem}.nav-toggle{display:block}.nav-menu{display:none;position:absolute;top:100%;left:0;right:0;background:var(--background-color);padding:1rem 0;border-bottom:1px solid var(--gray-200)}.nav-menu-active{display:block}.nav-list{flex-direction:column;gap:.1rem;padding:0 1.5rem}.nav-link{display:block;padding:.2rem 0}h1{font-size:2rem}.article-header{padding:2rem 0}.content{padding:.1rem 0}}table{width:100%;border-collapse:collapse;margin:20px 0;font-family:'Arial',sans-serif}th,td{padding:12px 15px;text-align:left;border:1px solid #ddd}th{background-color:#0F7F0B;color:#FFF}td{background-color:#f9f9f9}tr:nth-child(even) td{background-color:#f2f2f2}@media screen and (max-width:768px){table{border:0;display:block;overflow-x:auto;white-space:nowrap}th,td{padding:10px;text-align:right}th{background-color:#0F7F0B;color:#FFF}td{background-color:#f9f9f9;border-bottom:1px solid #ddd}tr:nth-child(even) td{background-color:#f2f2f2}}a{text-decoration:none;color:#540707}.katex-html{padding: .2rem;color: #000;font-weight: 700;font-size: 1.3rem;overflow-wrap: break-word;max-width: 100%;white-space: normal !important}.category{display:flex;align-items:center;gap:.5rem;flex-wrap:wrap;margin:1rem 0 1rem 0}.tag{font-size:1rem;font-weight:700;padding:.1rem .3rem .1rem .3rem;background:#0000000f;color:#000;border-radius:5px;font-family:"Newsreader",serif}.tag>a{text-decoration:none;color:#000}img{margin:auto;display:block;max-width:100%;height:auto;margin-bottom:1rem}.katex{white-space: pre-line !important;display: inline-block;max-width: 100%;overflow-x: auto;overflow-y: hidden;scrollbar-width: thin;overflow-wrap: break-word;word-break: break-word;vertical-align: -7px}.content > p {overflow-wrap: break-word;word-break: break-word}
    </style>
    <style type="text/css">
    	pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}
		.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-variable{color:#79c0ff}.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-code,.hljs-comment,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-pseudo,.hljs-selector-tag{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}
    	pre{-webkit-text-size-adjust:100%;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;font-weight:400;word-break:break-word;word-wrap:break-word;box-sizing:inherit;border-radius:4px;overflow-x:auto;font-family:source-code-pro,Menlo,Monaco,"Courier New",Courier,monospace}code{-webkit-text-size-adjust:100%;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;word-wrap:break-word;word-break:break-word;font-style:normal;line-height:20px;letter-spacing:-.003em;box-sizing:inherit;font-weight:400;font-size:75%;font-family:source-code-pro,Menlo,Monaco,"Courier New",Courier,monospace}
    </style>
    <style type="text/css">
    	.back-to-top{position:fixed;bottom:20px;right:20px;background-color:#a73f3f;color:#fff;padding:8px 10px;border-radius:50%;box-shadow:0 4px 6px rgb(0 0 0 / .2);font-size:10px;font-weight:700;text-decoration:none;text-align:center;transition:opacity 0.3s ease,visibility 0.3s ease;z-index:99999;opacity:1;visibility:visible}.back-to-top:hover{background-color:#0056b3}
    </style>
    <style type="text/css">
        .ad-header {margin: 1rem auto 1rem;background-color: #fdfdfd;text-align: center;display: block;}.ad-header .ad-wrapper {min-height: 90px;display: flex;align-items: center;justify-content: center;font-size: 1rem;color: #555;font-weight: 500;padding: 3rem;border: 1px dashed #ccc;border-radius: 6px;}@media (max-width: 768px) {.ad-header {padding: 0.75rem;}}.ad-sidebar {margin: 0 0 1rem;background-color: #fefefe;text-align: center;padding: 0px;width: 100%;max-width: 100%;display: block;}.ad-sidebar .ad-wrapper {min-height: 250px;display: flex;align-items: center;justify-content: center;font-size: 1rem;color: #444;font-weight: 500;border: 1px dashed #aaa;border-radius: 6px;padding: 0rem;}@media (max-width: 1024px) {.ad-sidebar {padding: 0.75rem;}}
    </style>
    <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "Article",
          "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://catatansoal.github.io/blog/rasterio-subset-images-by-top"
          },
          "headline": "Rasterio: Subset Images By Top-Left Coordinates &amp; Dimensions",
          "description": "Rasterio: Subset Images By Top-Left Coordinates & Dimensions...",
          "image": [
            "https://tse4.mm.bing.net/th?q=Rasterio%3A%20How%20to%20Subset%20Georeferenced%20Images%20by%20Top-Left%20Coordinates%20and%20Dimensions"
          ],
          "author": {
            "@type": "Person",
            "name": "ADMIN",
            "jobTitle": "Editor web"
          },
          "publisher": {
            "@type": "Organization",
            "name": "Question Notes",
            "logo": {
              "@type": "ImageObject",
              "url": "https://tse4.mm.bing.net/th?q=Question%20Notes"
            }
          },
          "datePublished": "2025-08-06T21:17:56+00:00",
          "dateModified": "2025-08-06T21:17:56+00:00"
        }
    </script>
</head>
<body>
    <header class="header">
        <nav class="nav">
            <div class="container nav-container">
                <div class="nav-left">
                    <span class="logo">Question Notes</span>
                    <span class="blog-tag">Article</span>
                </div>
                <div class="nav-search">
                    <form class="search-form" role="search">
                        <input 
                            type="search" 
                            class="search-input"
                            placeholder="Search articles..."
                            aria-label="Search articles"
                        >
                        <button type="submit" class="search-button" aria-label="Submit search">🔎</button>
                    </form>
                </div>
                <button class="nav-toggle" aria-label="Toggle navigation">
                    <span class="hamburger"></span>
                </button>
                <div class="nav-menu">
                    <ul class="nav-list">
                    	<li><a href="/" class="nav-link">HOME</a></li>
                        <li><a href="/pages/About" class="nav-link">About</a></li>
                        <li><a href="/pages/Contact" class="nav-link">Contact</a></li>
                        <li><a href="/pages/Disclaimer" class="nav-link">Disclaimer</a></li>
                        <li><a href="/pages/Privacy" class="nav-link">Privacy</a></li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>
    <main class="main">
        <article class="article">
            <header class="article-header">
                <div class="container">
                    <h1>Rasterio: Subset Images By Top-Left Coordinates &amp; Dimensions</h1>
                    <div class="meta">
                        <time datetime="2025-08-06T21:17:56+00:00">Aug 6, 2025</time>
                        <span class="author">by ADMIN</span>
                        <span class="view-count">
                            <span id="viewCount">61</span> views
                        </span>
                    </div>
                </div>
            </header>
            <div class="ad-header container">
                <!-- <div class="ad-wrapper">
    Iklan Headers
</div> -->
            </div>
            <div class="container">
                <div class="article-layout">
                    <div class="content">
                        <img src="https://tse4.mm.bing.net/th?q=Rasterio%3A%20How%20to%20Subset%20Georeferenced%20Images%20by%20Top-Left%20Coordinates%20and%20Dimensions" title="Rasterio: How to Subset Georeferenced Images by Top-Left Coordinates and Dimensions" width="300" height="200"/><p>Hey guys! Ever found yourself needing to extract a specific chunk from a massive georeferenced image, like a Sentinel dataset? It can be a bit tricky, especially when you're trying to pinpoint your subset using top-left coordinates and dimensions (height and width). But don't worry, we're diving into how to do just that with Rasterio, a powerful Python library for geospatial data.</p>
<h2>Understanding the Challenge</h2>
<p>When working with georeferenced images, you're dealing with data that has spatial context – meaning each pixel corresponds to a specific location on Earth. Often, you don't need the entire image; you just want a smaller area. Rasterio's <code>window</code> module is perfect for this, allowing you to define a rectangular region of interest. However, the common examples often use bounding box coordinates (left, top, right, bottom), which might not be the most intuitive when you have the top-left corner and the desired dimensions in mind.</p>
<p>So, how do we bridge this gap? How do we translate our top-left corner and dimensions into the bounding box coordinates that Rasterio's <code>from_bounds()</code> function expects? That's the puzzle we're going to solve. We will see how to use Rasterio effectively to select a subset of georeferenced image data using the top-left coordinates along with the desired height and width. Let's break down the problem and see how Rasterio can help us achieve this efficiently. We'll cover the key concepts, the code implementation, and some common pitfalls to avoid.</p>
<h2>Key Concepts: Windows and Transforms</h2>
<p>Before we jump into the code, let's clarify two fundamental concepts in Rasterio:</p>
<ul>
<li><strong>Windows:</strong> In Rasterio, a <strong><em>window</em></strong> represents a rectangular subset of an image. It's defined by row and column offsets and heights and widths in pixel units. Think of it as a viewport into your larger image. Windows are essential for reading only the data you need, which can significantly improve performance, especially with large datasets.</li>
<li><strong>Transforms:</strong> A <strong><em>transform</em></strong> is a matrix that maps pixel coordinates (row, column) to geographic coordinates (e.g., latitude, longitude) and vice versa. It's the bridge between the image's pixel space and the real world. Rasterio uses affine transformations, which are a common way to represent these spatial relationships. The transform allows us to know the real-world coordinates of each pixel in our image. This is crucial for accurately subsetting the data based on geographic location.</li>
</ul>
<p>These two concepts work hand-in-hand. The transform allows us to relate pixel locations to geographic coordinates, and windows allow us to specify which pixels we want to extract. By understanding these concepts, we can effectively use Rasterio to subset our georeferenced images.</p>
<h2>The Solution: Combining Transform and Window</h2>
<p>The key to solving our subsetting problem lies in understanding how to use the image's transform to convert our top-left coordinates and dimensions into a Rasterio window. Here's the breakdown:</p>
<ol>
<li><strong>Read the Image and Access the Transform:</strong> First, we need to open the raster dataset using <code>rasterio.open()</code> and access its transform property. This transform holds the information necessary to convert pixel coordinates to geographic coordinates.</li>
<li><strong>Calculate the Window:</strong> We will calculate the window based on our top-left coordinates and desired dimensions. This involves a bit of math, but don't worry, we'll walk through it step by step. The goal is to determine the row and column offsets and the height and width of our desired subset in pixel units.</li>
<li><strong>Read the Subset:</strong> Finally, we use the calculated window in the <code>dataset.read()</code> function to extract the desired subset of the image. This gives us a NumPy array containing only the data within our specified window.</li>
</ol>
<p>Let's get into the code.</p>
<h3>Code Implementation</h3>
<p>Here’s the Python code using Rasterio to subset a georeferenced image by top-left coordinates and dimensions:</p>
<pre><code class="hljs">import rasterio
from rasterio import windows
from affine import Affine

def subset_by_coords_and_dims(
    image_path, top_left_x, top_left_y, width, height
):
    &quot;&quot;&quot;Subsets a georeferenced image using top-left coordinates and dimensions.

    Args:
        image_path (str): Path to the georeferenced image.
        top_left_x (float): Top-left x-coordinate of the subset.
        top_left_y (float): Top-left y-coordinate of the subset.
        width (int): Width of the subset in pixels.
        height (int): Height of the subset in pixels.

    Returns:
        numpy.ndarray: Subset of the image as a NumPy array, or None if an error occurs.
    &quot;&quot;&quot;
    try:
        with rasterio.open(image_path) as dataset:
            # 1. Calculate pixel offsets
            row_start, col_start = dataset.index(top_left_x, top_left_y)

            # 2. Create the window
            window = windows.Window(
                col_start, row_start, width, height
            )

            # 3. Read the data within the window
            subset = dataset.read(1, window=window)

            return subset

    except rasterio.RasterioIOError as e:
        print(f&quot;Error: Could not open or read the image: {e}&quot;)
        return None
    except Exception as e:
        print(f&quot;An unexpected error occurred: {e}&quot;)
        return None


# Example usage:
image_path = &quot;path/to/your/image.tif&quot;  # Replace with your image path
top_left_x = 10.0
top_left_y = 20.0
width = 100
height = 100

subset = subset_by_coords_and_dims(
    image_path, top_left_x, top_left_y, width, height
)

if subset is not None:
    print(&quot;Subset shape:&quot;, subset.shape)
    # Process your subset here
else:
    print(&quot;Failed to extract subset.&quot;)
</code></pre>
<h3>Step-by-Step Explanation</h3>
<ol>
<li><strong>Import Libraries:</strong> We start by importing the necessary libraries: <code>rasterio</code>, <code>rasterio.windows</code>, and <code>affine</code>. Rasterio is the core library for reading and writing geospatial raster data. The windows module helps us define the subset, and the affine module (though not directly used in this simplified version) is crucial for understanding the image's spatial transformation.</li>
<li><strong>Define the Function:</strong> We define a function <code>subset_by_coords_and_dims</code> that takes the image path, top-left coordinates (x, y), and the desired width and height of the subset as input. This function encapsulates the logic for subsetting the image.</li>
<li><strong>Open the Dataset:</strong> Inside the function, we use <code>rasterio.open()</code> to open the raster dataset in read mode (<code>with</code> statement ensures proper file closure). This gives us a <code>dataset</code> object that we can use to access the image's metadata and data.</li>
<li><strong>Calculate Pixel Offsets:</strong> Here's where the magic happens. We use the <code>dataset.index(top_left_x, top_left_y)</code> method to convert the geographic coordinates (top-left x, top-left y) into pixel row and column indices. This method leverages the image's transform to perform this conversion. The transform maps world coordinates to pixel coordinates, and <code>dataset.index()</code> does the inverse, finding the pixel indices that correspond to a given geographic location. This is a crucial step in bridging the gap between real-world coordinates and the image's pixel grid.</li>
<li><strong>Create the Window:</strong> We create a <code>rasterio.windows.Window</code> object using the calculated column and row start indices, along with the desired width and height. The Window object represents the rectangular subset we want to extract. It essentially defines the viewport into our larger image.</li>
<li><strong>Read the Subset:</strong> We use <code>dataset.read(1, window=window)</code> to read the data within the defined window. The <code>1</code> specifies that we want to read the first band of the image (assuming it's a single-band image). The <code>window</code> parameter tells Rasterio to only read the data within the specified window, which significantly improves performance compared to reading the entire image. This returns a NumPy array containing the pixel values within our subset.</li>
<li><strong>Error Handling:</strong> We wrap the core logic in a <code>try...except</code> block to handle potential errors, such as <code>rasterio.RasterioIOError</code> (if the image can't be opened or read) and generic <code>Exception</code> for any other unexpected issues. This ensures that our function doesn't crash and provides informative error messages to the user.</li>
<li><strong>Example Usage:</strong> The example usage demonstrates how to call the function with a sample image path, top-left coordinates, width, and height. It then prints the shape of the resulting subset (which should be (height, width)) and includes a placeholder comment for further processing of the subset. If the subset extraction fails, it prints an error message.</li>
</ol>
<h3>Making it More Robust</h3>
<p>Let's enhance our function to handle edge cases and provide more flexibility.</p>
<ul>
<li><strong>Handling Multiple Bands:</strong> The current code assumes a single-band image. We can modify it to read multiple bands or all bands if needed. To read all bands, we can omit the band number in <code>dataset.read()</code> or iterate through the bands.</li>
<li><strong>Checking Window Boundaries:</strong> It's crucial to ensure that the calculated window doesn't extend beyond the image boundaries. We can add checks to adjust the window if it does, preventing errors.</li>
<li><strong>Using Offsets Directly:</strong> For advanced use cases, you might want to work directly with pixel offsets and sizes. Rasterio allows you to create windows directly from these values.</li>
</ul>
<p>Here’s an improved version of the function incorporating these enhancements:</p>
<pre><code class="hljs">import rasterio
from rasterio import windows
import numpy as np

def subset_by_coords_and_dims(
    image_path, top_left_x, top_left_y, width, height, bands=None
):
    &quot;&quot;&quot;Subsets a georeferenced image with enhanced error handling and band selection.

    Args:
        image_path (str): Path to the georeferenced image.
        top_left_x (float): Top-left x-coordinate of the subset.
        top_left_y (float): Top-left y-coordinate of the subset.
        width (int): Width of the subset in pixels.
        height (int): Height of the subset in pixels.
        bands (int or list of int, optional): Band(s) to read. Defaults to None (all bands).

    Returns:
        numpy.ndarray or list of numpy.ndarray: Subset of the image as a NumPy array (or a list
        of arrays if multiple bands are read), or None if an error occurs.
    &quot;&quot;&quot;
    try:
        with rasterio.open(image_path) as dataset:
            # 1. Calculate pixel offsets
            row_start, col_start = dataset.index(top_left_x, top_left_y)

            # 2. Calculate window and adjust if it exceeds image bounds
            window = windows.Window(
                col_start, row_start, width, height
            )
            window = window.intersection(dataset.window(*dataset.bounds))

            # 3. Read data for selected bands
            if bands is None:
                # Read all bands
                subset = dataset.read(window=window)
            elif isinstance(bands, int):
                # Read a single band
                subset = dataset.read(bands, window=window)
            elif isinstance(bands, list):
                # Read multiple bands
                subset = [dataset.read(band, window=window) for band in bands]
            else:
                raise ValueError(
                    &quot;bands must be None, an int, or a list of ints&quot;
                )

            return subset

    except rasterio.RasterioIOError as e:
        print(f&quot;Error: Could not open or read the image: {e}&quot;)
        return None
    except ValueError as e:
        print(f&quot;Error: {e}&quot;)
        return None
    except Exception as e:
        print(f&quot;An unexpected error occurred: {e}&quot;)
        return None


# Example usage:
image_path = &quot;path/to/your/image.tif&quot;  # Replace with your image path
top_left_x = 10.0
top_left_y = 20.0
width = 100
height = 100

# Read all bands
subset_all_bands = subset_by_coords_and_dims(
    image_path, top_left_x, top_left_y, width, height
)

if subset_all_bands is not None:
    if isinstance(subset_all_bands, list):
        print(&quot;Shape of band 1 subset:&quot;, subset_all_bands[0].shape)
    else:
        print(&quot;Shape of subset (all bands):&quot;, subset_all_bands.shape)
else:
    print(&quot;Failed to extract subset (all bands).&quot;)

# Read only band 1
subset_band_1 = subset_by_coords_and_dims(
    image_path, top_left_x, top_left_y, width, height, bands=1
)

if subset_band_1 is not None:
    print(&quot;Shape of subset (band 1):&quot;, subset_band_1.shape)
else:
    print(&quot;Failed to extract subset (band 1).&quot;)

# Read bands 1 and 3
subset_bands_1_3 = subset_by_coords_and_dims(
    image_path, top_left_x, top_left_y, width, height, bands=[1, 3]
)

if subset_bands_1_3 is not None:
    print(&quot;Shape of band 1 subset:&quot;, subset_bands_1_3[0].shape)
    print(&quot;Shape of band 3 subset:&quot;, subset_bands_1_3[1].shape)
else:
    print(&quot;Failed to extract subset (bands 1 and 3).&quot;)
</code></pre>
<h3>Key Improvements</h3>
<ul>
<li><strong>Band Selection:</strong> The function now accepts an optional <code>bands</code> argument. You can specify a single band (as an integer), a list of bands, or leave it as <code>None</code> to read all bands. This makes the function much more versatile.</li>
<li><strong>Window Intersection:</strong> We've added a crucial step to ensure that the calculated window does not extend beyond the image boundaries. The line <code>window = window.intersection(dataset.window(*dataset.bounds))</code> calculates the intersection of our desired window with the image's actual bounds. This prevents errors that can occur when trying to read data outside the image's extent. The <code>dataset.bounds</code> property returns the bounding box of the image in geographic coordinates, and <code>dataset.window(*dataset.bounds)</code> converts these bounds into a pixel window. The <code>intersection()</code> method then gives us the overlapping portion, ensuring we only read valid data.</li>
<li><strong>Multiple Bands Handling:</strong> The code now handles different cases for the <code>bands</code> argument: if it's <code>None</code>, it reads all bands at once; if it's an integer, it reads a single band; and if it's a list, it reads multiple bands using a list comprehension. This provides a clean and efficient way to handle different band selection scenarios.</li>
<li><strong>Value Error Handling:</strong> The function now includes a <code>ValueError</code> exception to catch cases where the <code>bands</code> argument is not of the expected type (None, int, or list of ints). This adds an extra layer of robustness by validating the input and providing a helpful error message.</li>
</ul>
<h2>Common Pitfalls and How to Avoid Them</h2>
<ul>
<li><strong>Incorrect Coordinates:</strong> Ensure your top-left coordinates are in the same coordinate reference system (CRS) as the image. Mismatched CRSs will lead to incorrect subsetting. Always double-check the CRS of your data and your coordinates.</li>
<li><strong>Off-by-One Errors:</strong> Pixel indexing can be tricky. Remember that pixel coordinates start at 0. Double-check your calculations, especially when converting between geographic coordinates and pixel indices.</li>
<li><strong>Window Boundaries:</strong> As we discussed, always ensure your window stays within the image boundaries. The <code>window.intersection()</code> method is your friend here!</li>
<li><strong>Memory Issues:</strong> Reading large subsets can consume a lot of memory. If you're working with extremely large images, consider reading smaller chunks or using techniques like tiling.</li>
</ul>
<p>By being mindful of these potential issues, you can ensure your subsetting operations are accurate and efficient.</p>
<h2>Conclusion</h2>
<p>Subsetting georeferenced images using top-left coordinates and dimensions is a common task in geospatial analysis. Rasterio provides the tools to do this efficiently. By understanding the concepts of windows and transforms, and by using the <code>dataset.index()</code> method, you can accurately extract the data you need. Remember to handle edge cases and potential errors to make your code robust. So, go ahead, give it a try, and unlock the power of targeted data extraction with Rasterio! Hope this helps, and happy coding, guys!</p>

                    </div>
                    <aside class="related-posts">
                        <div class="ad-sidebar container">
                            <!-- <div class="ad-wrapper">
    <span>Iklan Related</span>
</div> -->
                        </div>
                        <h2 class="related-posts-title">Related Posts</h2><article class="related-post">
                            <h3 class="related-post-title">
                                <a href="https://catatansoal.github.io/blog/tcl-tv-service-centre-gurugram">TCL TV Service Centre Gurugram: Reviews &amp; Repair Guide</a>
                            </h3>
                            <div class="meta">
                            	<time datetime="2025-08-11T14:32:48+00:00">Aug 11, 2025</time>
		                        <span class="view-count">
									54 views
		                        </span>
                            </div>
                        </article><article class="related-post">
                            <h3 class="related-post-title">
                                <a href="https://catatansoal.github.io/blog/petting-a-bearded-dragon-the">Petting A Bearded Dragon: The Ultimate Guide</a>
                            </h3>
                            <div class="meta">
                            	<time datetime="2025-08-06T11:50:51+00:00">Aug 6, 2025</time>
		                        <span class="view-count">
									44 views
		                        </span>
                            </div>
                        </article><article class="related-post">
                            <h3 class="related-post-title">
                                <a href="https://catatansoal.github.io/blog/understanding-3r-2-3r-0">Understanding 3r/2 - 3r/0 And Division By Zero In Mathematics</a>
                            </h3>
                            <div class="meta">
                            	<time datetime="2025-07-16T18:26:10+00:00">Jul 16, 2025</time>
		                        <span class="view-count">
									61 views
		                        </span>
                            </div>
                        </article><article class="related-post">
                            <h3 class="related-post-title">
                                <a href="https://catatansoal.github.io/blog/stalking-what-to-do-if">Stalking: What To Do If You&#39;re Being Stalked</a>
                            </h3>
                            <div class="meta">
                            	<time datetime="2025-08-10T03:29:24+00:00">Aug 10, 2025</time>
		                        <span class="view-count">
									44 views
		                        </span>
                            </div>
                        </article><article class="related-post">
                            <h3 class="related-post-title">
                                <a href="https://catatansoal.github.io/blog/troubleshooting-error-failed-to-update">Troubleshooting Error Failed To Update Threat Score For 192.168.55.210</a>
                            </h3>
                            <div class="meta">
                            	<time datetime="2025-07-16T16:20:16+00:00">Jul 16, 2025</time>
		                        <span class="view-count">
									70 views
		                        </span>
                            </div>
                        </article>
                    </aside>
                    <aside class="related-posts"></aside>
                </div>
            </div>
        </article>
        <a href="#" class="back-to-top" id="backToTop" title="Back to top">
        	<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-bar-up" viewBox="0 0 16 16">
			  <path fill-rule="evenodd" d="M3.646 11.854a.5.5 0 0 0 .708 0L8 8.207l3.646 3.647a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 0 0 0 .708M2.4 5.2c0 .22.18.4.4.4h10.4a.4.4 0 0 0 0-.8H2.8a.4.4 0 0 0-.4.4"/>
			</svg>
		</a>
    </main>
    <footer class="footer">
        <div class="container">
            <p>© 2025 Question Notes</p>
        </div>
    </footer>
    <script>
    	(() => {
            const navToggle = document.querySelector('.nav-toggle');
            const navMenu = document.querySelector('.nav-menu');
            const toggleMenu = () => {
                navMenu.classList.toggle('nav-menu-active');
                navToggle.classList.toggle('nav-toggle-active');
            };
            const backToTopHandler = (e) => {
                e.preventDefault();
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };
            navToggle.addEventListener('click', toggleMenu);
            document.getElementById('backToTop').addEventListener('click', backToTopHandler);
            window.addEventListener('pagehide', () => {
                navToggle.removeEventListener('click', toggleMenu);
                document.getElementById('backToTop').removeEventListener('click', backToTopHandler);
            });
        })();
		(() => {
            window.addEventListener("DOMContentLoaded", (event) => {
                const ellHljs = document.createElement("script");
                ellHljs.setAttribute("src", "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js");
                ellHljs.onload = () => {
                    hljs.highlightAll();
                };
                document.querySelector("body").append(ellHljs);
                const ellFont = document.createElement("link");
                ellFont.setAttribute("href", "https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css");
                ellFont.setAttribute("rel", "stylesheet");
                document.querySelector("head").append(ellFont);
                window.addEventListener('pagehide', () => {
                    // ellHljs.remove();
                    ellFont.remove();
                });

            });
        })();
    </script>
    <!-- Histats.com  START  (aync)-->
<script type="text/javascript">var _Hasync= _Hasync|| [];
_Hasync.push(['Histats.start', '1,4957095,4,0,0,0,00010000']);
_Hasync.push(['Histats.fasi', '1']);
_Hasync.push(['Histats.track_hits', '']);
(function() {
var hs = document.createElement('script'); hs.type = 'text/javascript'; hs.async = true;
hs.src = ('//s10.histats.com/js15_as.js');
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(hs);
})();</script>
<!-- Histats.com  END  -->
    
    
</body>
</html>
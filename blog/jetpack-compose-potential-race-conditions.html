<!DOCTYPE html>
<html lang="en">
<head>
	<title>Jetpack Compose Potential Race Conditions In Navigation With ViewModelScope</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Jetpack Compose Potential Race Conditions In Navigation With ViewModelScope...">
    <link rel="canonical" href="https://catatansoal.github.io/blog/jetpack-compose-potential-race-conditions">
	<meta property="og:type" content="article">
	<meta property="og:title" content="Jetpack Compose Potential Race Conditions In Navigation With ViewModelScope">
	<meta property="og:description" content="Jetpack Compose Potential Race Conditions In Navigation With ViewModelScope...">
	<meta property="og:url" content="https://catatansoal.github.io/blog/jetpack-compose-potential-race-conditions">
	<meta property="og:site_name" content="Question Notes">
	<meta property="article:published_time" content="2025-07-19T13:08:48+00:00">
	<meta property="article:author" content="ADMIN">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="preload" as="script" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js">
    <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <link rel="preload" fetchpriority="high" as="image" href="https://tse4.mm.bing.net/th?q=Jetpack%20Compose%20Navigational%20Race%20Conditions%20and%20ViewModelScope">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style type="text/css">
    	:root{--primary-color:#3740ff;--text-color:#202124;--background-color:#ffffff;--gray-100:#f8f9fa;--gray-200:#e9ecef}*{margin:0;padding:0;box-sizing:border-box}body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;line-height:1.6;color:var(--text-color);background-color:var(--background-color)}.container{max-width:1200px;margin:0 auto;padding:0 1.5rem}.header{background-color:var(--background-color);border-bottom:1px solid var(--gray-200);position:sticky;top:0;z-index:100}.nav{padding:.5rem 0}.nav-container{display:flex;justify-content:space-between;align-items:center;gap:1rem}.nav-left{display:flex;align-items:center;flex-shrink:0}.logo{font-weight:700;color:var(--primary-color)}.blog-tag{margin-left:1rem;padding:.25rem .5rem;background-color:var(--gray-100);border-radius:4px;font-size:.875rem}.nav-search{flex-grow:1;max-width:300px}.search-form{position:relative;width:100%}.search-input{width:100%;padding:.5rem 2.5rem .5rem 1rem;border:1px solid var(--gray-200);border-radius:24px;font-size:.875rem;transition:all 0.2s}.search-input:focus{outline:none;border-color:var(--primary-color);box-shadow:0 0 0 2px rgb(55 64 255 / .1)}.search-button{position:absolute;right:.5rem;top:50%;transform:translateY(-50%);background:none;border:none;color:#5f6368;cursor:pointer;padding:.25rem;display:flex;align-items:center;justify-content:center}.search-button:hover{color:var(--primary-color)}.nav-toggle{display:none;background:none;border:none;cursor:pointer;padding:.5rem}.hamburger{display:block;position:relative;width:24px;height:2px;background:var(--text-color);transition:all 0.3s}.hamburger::before,.hamburger::after{content:'';position:absolute;width:24px;height:2px;background:var(--text-color);transition:all 0.3s}.hamburger::before{top:-6px}.hamburger::after{bottom:-6px}.nav-toggle-active .hamburger{background:#fff0}.nav-toggle-active .hamburger::before{transform:rotate(45deg);top:0}.nav-toggle-active .hamburger::after{transform:rotate(-45deg);bottom:0}.nav-list{display:flex;list-style:none;gap:2rem}.nav-link{color:var(--text-color);text-decoration:none;font-size:.9rem;transition:color 0.2s}.nav-link:hover{color:var(--primary-color)}.article-header{padding:2rem 0;background-color:var(--gray-100)}.article-layout{display:grid;grid-template-columns:1fr 350px;gap:3rem;padding:1rem 0;align-items: start}h1,h2,h3,h4,h5,h6{font-family:"Crimson Text","Times New Roman",Times,serif}h1{font-size:2.5rem;line-height:1.2;margin-bottom:1rem}.meta{color:#5f6368;font-size:.875rem;display:flex;align-items:center;gap:1rem;flex-wrap:wrap}.view-count{display:inline-flex;align-items:center;gap:.25rem}.view-count svg{color:#5f6368}.content{min-width:0;border-bottom:1px solid #dddddd5e;margin-top:1rem;white-space:pre-line !important;overflow-wrap:break-word;overflow-x:auto;word-break:break-word}.lead{font-size:1.25rem;color:#5f6368;margin-bottom:2rem}h2,h3,h4,h5,h6{font-size:1.75rem;margin:1rem 0 1rem}p,pre,ol,ul>li{margin-bottom:1rem;font-family:"Newsreader",serif;font-optical-sizing:auto;font-style:normal;font-size:1.3rem;text-align: justify;}p>code{font-size:1rem;font-weight:700;padding:.1rem .3rem .1rem .3rem;background:#0000000f;color:#000;border-radius:5px}hr{margin:1rem 0 1rem 0}.code-example{background-color:var(--gray-100);padding:1.5rem;border-radius:8px;margin:1.5rem 0;overflow-x:auto}code{font-family:'Roboto Mono',monospace;font-size:.875rem}ul{margin:.2rem 0;padding-left:1.5rem}.related-posts{background-color:var(--gray-100);padding:1.5rem;border-radius:8px;position:sticky;top:5rem}.related-posts-title,.newpost-posts-list{font-size:1.75rem;margin:0 0 1rem}.related-posts-list{display:flex;flex-direction:column;gap:.5rem}.related-post,.newpost-post{border-bottom:1px solid #ddd;padding-bottom:10px;margin-bottom:10px}.related-post:last-child,.newpost-post:last-child{padding-bottom:0;border-bottom:none}.related-post-title,.newpost-post-title{font-size:1.2rem;margin:0 0 .1rem;font-family:"Newsreader",serif;font-optical-sizing:auto;font-style:normal;display: -webkit-box;-webkit-line-clamp: 3;-webkit-box-orient: vertical;overflow: hidden;}.related-post-title a,.newpost-post-title a{color:var(--text-color);text-decoration:none;transition:color 0.2s}.related-post-title a:hover,.newpost-post-title a:hover{color:var(--primary-color)}.related-post time{font-size:.875rem;color:#5f6368}.footer{background-color:var(--gray-100);padding:2rem 0;margin-top:4rem;color:#5f6368;font-size:.875rem}.nav-menu>ul>li{margin-bottom:0}@media (max-width:1024px){.container{max-width:800px}.article-layout{grid-template-columns:1fr;gap:2rem}.related-posts{position:static}}@media (max-width:768px){.nav-container{flex-wrap:wrap}.nav-search{order:3;max-width:none;width:100%;margin-top:.1rem}.nav-toggle{display:block}.nav-menu{display:none;position:absolute;top:100%;left:0;right:0;background:var(--background-color);padding:1rem 0;border-bottom:1px solid var(--gray-200)}.nav-menu-active{display:block}.nav-list{flex-direction:column;gap:.1rem;padding:0 1.5rem}.nav-link{display:block;padding:.2rem 0}h1{font-size:2rem}.article-header{padding:2rem 0}.content{padding:.1rem 0}}table{width:100%;border-collapse:collapse;margin:20px 0;font-family:'Arial',sans-serif}th,td{padding:12px 15px;text-align:left;border:1px solid #ddd}th{background-color:#0F7F0B;color:#FFF}td{background-color:#f9f9f9}tr:nth-child(even) td{background-color:#f2f2f2}@media screen and (max-width:768px){table{border:0;display:block;overflow-x:auto;white-space:nowrap}th,td{padding:10px;text-align:right}th{background-color:#0F7F0B;color:#FFF}td{background-color:#f9f9f9;border-bottom:1px solid #ddd}tr:nth-child(even) td{background-color:#f2f2f2}}a{text-decoration:none;color:#540707}.katex-html{padding: .2rem;color: #000;font-weight: 700;font-size: 1.3rem;overflow-wrap: break-word;max-width: 100%;white-space: normal !important}.category{display:flex;align-items:center;gap:.5rem;flex-wrap:wrap;margin:1rem 0 1rem 0}.tag{font-size:1rem;font-weight:700;padding:.1rem .3rem .1rem .3rem;background:#0000000f;color:#000;border-radius:5px;font-family:"Newsreader",serif}.tag>a{text-decoration:none;color:#000}img{margin:auto;display:block;max-width:100%;height:auto;margin-bottom:1rem}.katex{white-space: pre-line !important;display: inline-block;max-width: 100%;overflow-x: auto;overflow-y: hidden;scrollbar-width: thin;overflow-wrap: break-word;word-break: break-word;vertical-align: -7px}.content > p {overflow-wrap: break-word;word-break: break-word}
    </style>
    <style type="text/css">
    	pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}
		.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-variable{color:#79c0ff}.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-code,.hljs-comment,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-pseudo,.hljs-selector-tag{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}
    	pre{-webkit-text-size-adjust:100%;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;font-weight:400;word-break:break-word;word-wrap:break-word;box-sizing:inherit;border-radius:4px;overflow-x:auto;font-family:source-code-pro,Menlo,Monaco,"Courier New",Courier,monospace}code{-webkit-text-size-adjust:100%;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;word-wrap:break-word;word-break:break-word;font-style:normal;line-height:20px;letter-spacing:-.003em;box-sizing:inherit;font-weight:400;font-size:75%;font-family:source-code-pro,Menlo,Monaco,"Courier New",Courier,monospace}
    </style>
    <style type="text/css">
    	.back-to-top{position:fixed;bottom:20px;right:20px;background-color:#a73f3f;color:#fff;padding:8px 10px;border-radius:50%;box-shadow:0 4px 6px rgb(0 0 0 / .2);font-size:10px;font-weight:700;text-decoration:none;text-align:center;transition:opacity 0.3s ease,visibility 0.3s ease;z-index:99999;opacity:1;visibility:visible}.back-to-top:hover{background-color:#0056b3}
    </style>
    <style type="text/css">
        .ad-header {margin: 1rem auto 1rem;background-color: #fdfdfd;text-align: center;display: block;}.ad-header .ad-wrapper {min-height: 90px;display: flex;align-items: center;justify-content: center;font-size: 1rem;color: #555;font-weight: 500;padding: 3rem;border: 1px dashed #ccc;border-radius: 6px;}@media (max-width: 768px) {.ad-header {padding: 0.75rem;}}.ad-sidebar {margin: 0 0 1rem;background-color: #fefefe;text-align: center;padding: 0px;width: 100%;max-width: 100%;display: block;}.ad-sidebar .ad-wrapper {min-height: 250px;display: flex;align-items: center;justify-content: center;font-size: 1rem;color: #444;font-weight: 500;border: 1px dashed #aaa;border-radius: 6px;padding: 0rem;}@media (max-width: 1024px) {.ad-sidebar {padding: 0.75rem;}}
    </style>
    <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "Article",
          "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://catatansoal.github.io/blog/jetpack-compose-potential-race-conditions"
          },
          "headline": "Jetpack Compose Potential Race Conditions In Navigation With ViewModelScope",
          "description": "Jetpack Compose Potential Race Conditions In Navigation With ViewModelScope...",
          "image": [
            "https://tse4.mm.bing.net/th?q=Jetpack%20Compose%20Navigational%20Race%20Conditions%20and%20ViewModelScope"
          ],
          "author": {
            "@type": "Person",
            "name": "ADMIN",
            "jobTitle": "Editor web"
          },
          "publisher": {
            "@type": "Organization",
            "name": "Question Notes",
            "logo": {
              "@type": "ImageObject",
              "url": "https://tse4.mm.bing.net/th?q=Question%20Notes"
            }
          },
          "datePublished": "2025-07-19T13:08:48+00:00",
          "dateModified": "2025-07-19T13:08:48+00:00"
        }
    </script>
</head>
<body>
    <header class="header">
        <nav class="nav">
            <div class="container nav-container">
                <div class="nav-left">
                    <span class="logo">Question Notes</span>
                    <span class="blog-tag">Article</span>
                </div>
                <div class="nav-search">
                    <form class="search-form" role="search">
                        <input 
                            type="search" 
                            class="search-input"
                            placeholder="Search articles..."
                            aria-label="Search articles"
                        >
                        <button type="submit" class="search-button" aria-label="Submit search">ðŸ”Ž</button>
                    </form>
                </div>
                <button class="nav-toggle" aria-label="Toggle navigation">
                    <span class="hamburger"></span>
                </button>
                <div class="nav-menu">
                    <ul class="nav-list">
                    	<li><a href="/" class="nav-link">HOME</a></li>
                        <li><a href="/pages/About" class="nav-link">About</a></li>
                        <li><a href="/pages/Contact" class="nav-link">Contact</a></li>
                        <li><a href="/pages/Disclaimer" class="nav-link">Disclaimer</a></li>
                        <li><a href="/pages/Privacy" class="nav-link">Privacy</a></li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>
    <main class="main">
        <article class="article">
            <header class="article-header">
                <div class="container">
                    <h1>Jetpack Compose Potential Race Conditions In Navigation With ViewModelScope</h1>
                    <div class="meta">
                        <time datetime="2025-07-19T13:08:48+00:00">Jul 19, 2025</time>
                        <span class="author">by ADMIN</span>
                        <span class="view-count">
                            <span id="viewCount">76</span> views
                        </span>
                    </div>
                </div>
            </header>
            <div class="ad-header container">
                <!-- <div class="ad-wrapper">
    Iklan Headers
</div> -->
            </div>
            <div class="container">
                <div class="article-layout">
                    <div class="content">
                        <img src="https://tse4.mm.bing.net/th?q=Jetpack%20Compose%20Navigational%20Race%20Conditions%20and%20ViewModelScope" title="Jetpack Compose Navigational Race Conditions and ViewModelScope" width="300" height="200"/>
<p>Hey guys! Let's dive into a tricky situation you might encounter when building Android apps with Jetpack Compose and Navigation, specifically concerning potential race conditions arising from the interaction between navigation events and <code>ViewModelScope</code>. This is a common scenario, especially when dealing with <code>onClick</code> lambdas that trigger actions within your <code>ViewModel</code>. Let's break it down and see how we can keep our apps running smoothly.</p>
<h2>The Core Issue: ViewModelScope and Navigation Interactions</h2>
<p>At the heart of the matter lies the interplay between <strong><code>ViewModelScope</code></strong>, which is designed to tie coroutines to the lifecycle of a <code>ViewModel</code>, and navigation events in Jetpack Compose. Often, in our composables, we have buttons or clickable elements whose <code>onClick</code> lambdas initiate actions. These actions frequently involve launching coroutines within the <code>ViewModelScope</code> using <code>viewModelScope.launch { ... }</code>. This is a standard practice for performing background tasks, network requests, or database operations without blocking the main thread. However, here's where the potential race condition creeps in: what happens if the <code>ViewModelScope</code> gets cancelled <em>before</em> the launched action completes?</p>
<p>To truly grasp this, let's paint a picture. Imagine a user taps a button that triggers a network request via a coroutine launched in <code>ViewModelScope</code>. Simultaneously, or very shortly after, the user navigates away from the screen. This navigation event might trigger the <code>ViewModel</code>'s <code>onCleared()</code> method, which, in turn, cancels the <code>ViewModelScope</code>. Now, if the network request hasn't finished yet, there's a chance it could be interrupted mid-flight, or even worse, try to update UI elements that no longer exist because the screen has changed. This can lead to unexpected behavior, crashes, or data inconsistencies â€“ none of which are desirable, right?</p>
<p>We need to ensure that our background tasks either complete gracefully before the <code>ViewModelScope</code> is cancelled or are handled in a way that doesn't cause problems if cancellation occurs. This involves careful consideration of how we structure our coroutines and how we interact with the UI from within them. Think about scenarios like saving data, updating a local database, or posting information to a server. If these actions are interrupted prematurely, what are the consequences? Will data be lost? Will the application crash? These are the questions we need to address to build robust and reliable apps.</p>
<p>One of the key aspects to consider is the timing of the <code>onCleared()</code> call. When a composable is no longer part of the composition, and its associated <code>ViewModel</code> is no longer needed, the system will eventually call <code>onCleared()</code>. However, there's no guarantee when this will happen relative to navigation events. It could happen almost immediately after navigation, or it could be delayed. This uncertainty is what makes the race condition so insidious. We need to be proactive in managing the lifecycle of our coroutines to avoid these issues.</p>
<p>Furthermore, it's essential to understand that different navigation strategies can influence the likelihood of encountering this race condition. For instance, if you're using a navigation stack where screens are pushed and popped, the <code>ViewModel</code> for a screen might be retained in memory even after the screen is no longer visible. This can mitigate the risk, but it's not a foolproof solution. On the other hand, if you're using a navigation pattern that aggressively clears the back stack, the <code>ViewModel</code> might be cleared more quickly, increasing the risk of a race condition. The choice of navigation strategy, therefore, has a direct impact on how we manage our coroutines.</p>
<p>Ultimately, the goal is to create a seamless user experience, even in the face of complex navigation patterns and asynchronous operations. This requires a deep understanding of how <code>ViewModelScope</code> interacts with navigation events and a proactive approach to handling potential race conditions. Let's explore some concrete examples and solutions to help you tackle this challenge head-on!</p>
<h2>Illustrative Scenario: A Practical Example</h2>
<p>To make this more tangible, let's walk through a concrete scenario. Imagine you have a screen in your app where users can submit feedback. When the user taps the &quot;Submit&quot; button, you launch a coroutine in <code>ViewModelScope</code> to send the feedback to your server. Here's some simplified code to illustrate:</p>
<pre><code class="hljs">class FeedbackViewModel : ViewModel() {
    private val _feedbackSent = MutableStateFlow(false)
    val feedbackSent: StateFlow&lt;Boolean&gt; = _feedbackSent.asStateFlow()

    fun submitFeedback(feedbackText: String) {
        viewModelScope.launch {
            try {
                // Simulate network request
                delay(2000) // Simulate 2 seconds of network latency
                sendFeedbackToServer(feedbackText)
                _feedbackSent.value = true
            } catch (e: CancellationException) {
                // Coroutine was cancelled, handle it gracefully
                Log.d(&quot;FeedbackViewModel&quot;, &quot;Feedback submission cancelled&quot;)
            } catch (e: Exception) {
                // Handle other exceptions
                Log.e(&quot;FeedbackViewModel&quot;, &quot;Error submitting feedback&quot;, e)
            }
        }
    }

    private suspend fun sendFeedbackToServer(feedbackText: String) {
        // Your actual network call here
        Log.d(&quot;FeedbackViewModel&quot;, &quot;Sending feedback: $feedbackText&quot;)
        // Simulate sending
        delay(1000)
        Log.d(&quot;FeedbackViewModel&quot;, &quot;Feedback Sent&quot;)
    }
}

@Composable
fun FeedbackScreen(viewModel: FeedbackViewModel, navController: NavController) {
    val feedbackSent by viewModel.feedbackSent.collectAsState()
    var feedbackText by rememberSaveable { mutableStateOf(&quot;&quot;) }

    Column(modifier = Modifier.padding(16.dp)) {
        TextField(
            value = feedbackText,
            onValueChange = { feedbackText = it },
            label = { Text(&quot;Feedback&quot;) }
        )
        Button(onClick = {
            viewModel.submitFeedback(feedbackText)
        }) {
            Text(&quot;Submit&quot;)
        }

        if (feedbackSent) {
            Text(&quot;Feedback submitted successfully!&quot;)
            // Navigate back after a delay
            LaunchedEffect(Unit) {
                delay(1000) // Delay before navigating back
                navController.popBackStack()
            }
        }
    }
}
</code></pre>
<p>In this scenario, the <code>submitFeedback</code> function launches a coroutine to simulate sending feedback to a server. The <code>feedbackSent</code> state is updated to reflect the success of the operation, and a <code>LaunchedEffect</code> is used to navigate back to the previous screen after a short delay.</p>
<p>Now, imagine the user taps the &quot;Submit&quot; button and then <em>immediately</em> presses the back button or navigates to a different part of the app. If the <code>sendFeedbackToServer</code> coroutine hasn't completed yet, the <code>ViewModelScope</code> might be cancelled, and the coroutine could be interrupted. This could leave the user in a state of uncertainty â€“ did their feedback actually get submitted? Or, even worse, if the navigation occurs <em>after</em> the <code>feedbackSent</code> state is updated but <em>before</em> the <code>LaunchedEffect</code>'s delay completes, the app might try to navigate back from a screen that no longer exists, leading to a crash.</p>
<p>This example highlights the real-world implications of the race condition we're discussing. It's not just a theoretical problem; it's something that can affect the user experience and the stability of your app. The key takeaway here is that we need to be mindful of these potential issues and implement strategies to mitigate them.</p>
<p>Furthermore, let's consider what happens if the <code>sendFeedbackToServer</code> function involves more complex operations, such as saving data to a local database before sending it to the server. If the coroutine is cancelled mid-operation, you might end up with inconsistent data in your database, or even data loss. This underscores the importance of using transactional operations and other techniques to ensure data integrity in the face of cancellation.</p>
<p>The <code>CancellationException</code> within the <code>try...catch</code> block is a crucial element of handling these situations. It allows us to detect when a coroutine has been cancelled and to perform any necessary cleanup or rollback operations. For instance, we might want to revert changes made to the database or notify the user that the operation was not completed successfully. However, simply catching the exception is not enough. We need to design our coroutines in a way that they can be cancelled safely and without leaving the application in an inconsistent state.</p>
<p>Ultimately, understanding this scenario and its potential pitfalls is the first step towards building more robust and reliable Jetpack Compose applications. By carefully considering the lifecycle of our coroutines and how they interact with navigation events, we can avoid these race conditions and create a smoother user experience.</p>
<h2>Solutions and Best Practices: Taming the Race Condition</h2>
<p>Okay, so we've established the problem â€“ now let's talk solutions! There are several strategies we can employ to mitigate these potential race conditions and ensure our apps behave predictably, even when navigation events occur while coroutines are running. These best practices involve careful management of coroutine lifecycles, handling cancellation gracefully, and decoupling UI updates from background operations.</p>
<p>One of the most effective approaches is to <strong>use <code>withContext(NonCancellable)</code> for critical sections of code</strong>. This allows you to execute a block of code that will not be cancelled, even if the <code>ViewModelScope</code> is cancelled. This is particularly useful for operations that <em>must</em> complete, such as saving data to a database or committing a transaction. However, use this sparingly! Overusing <code>NonCancellable</code> can lead to memory leaks and other issues if your coroutines don't terminate properly. Think of it as a safety net for those absolutely essential tasks that can't be interrupted.</p>
<p>Here's how you might apply it to our feedback submission example:</p>
<pre><code class="hljs">fun submitFeedback(feedbackText: String) {
    viewModelScope.launch {
        try {
            // Simulate network request
            delay(2000) // Simulate 2 seconds of network latency
            withContext(NonCancellable) {
                try {
                    sendFeedbackToServer(feedbackText)
                    _feedbackSent.value = true
                } catch (e: Exception) {
                    // Handle exceptions within NonCancellable
                    Log.e(&quot;FeedbackViewModel&quot;, &quot;Error submitting feedback (NonCancellable)&quot;, e)
                }
            }
        } catch (e: CancellationException) {
            // Coroutine was cancelled, handle it gracefully
            Log.d(&quot;FeedbackViewModel&quot;, &quot;Feedback submission cancelled&quot;)
        } catch (e: Exception) {
            // Handle other exceptions
            Log.e(&quot;FeedbackViewModel&quot;, &quot;Error submitting feedback&quot;, e)
        }
    }
}
</code></pre>
<p>In this modified code, the <code>sendFeedbackToServer</code> call is wrapped in a <code>withContext(NonCancellable)</code> block. This ensures that the feedback is sent to the server, even if the <code>ViewModelScope</code> is cancelled due to navigation. It's crucial to include a <code>try...catch</code> block <em>within</em> the <code>NonCancellable</code> context to handle any exceptions that might occur during the critical operation. This prevents unhandled exceptions from crashing the application.</p>
<p>Another crucial technique is <strong>graceful cancellation handling</strong>. Always check for <code>CancellationException</code> within your coroutines and handle it appropriately. This might involve rolling back changes, releasing resources, or notifying the user that the operation was not completed. The key is to avoid leaving your application in an inconsistent state. Remember, catching the exception is only half the battle; you need to take meaningful action in response to it.</p>
<p><strong>Decoupling UI updates from background operations</strong> is another vital strategy. Instead of directly updating UI state from within a coroutine that might be cancelled, consider using a separate mechanism, such as a <code>Channel</code> or a <code>SharedFlow</code>, to communicate results back to the UI. This allows you to buffer updates and handle them even if the coroutine is cancelled. For example, you can emit the result of an operation to a <code>SharedFlow</code> and then collect the results in your composable. If the composable is no longer active, the collection will simply stop, preventing potential crashes.</p>
<pre><code class="hljs">class FeedbackViewModel : ViewModel() {
    private val _feedbackResult = MutableSharedFlow&lt;Result&lt;Unit&gt;&gt;()
    val feedbackResult: SharedFlow&lt;Result&lt;Unit&gt;&gt; = _feedbackResult.asSharedFlow()

    fun submitFeedback(feedbackText: String) {
        viewModelScope.launch {
            try {
                // Simulate network request
                delay(2000) // Simulate 2 seconds of network latency
                sendFeedbackToServer(feedbackText)
                _feedbackResult.emit(Result.success(Unit))
            } catch (e: CancellationException) {
                // Coroutine was cancelled, handle it gracefully
                Log.d(&quot;FeedbackViewModel&quot;, &quot;Feedback submission cancelled&quot;)
            } catch (e: Exception) {
                // Handle other exceptions
                Log.e(&quot;FeedbackViewModel&quot;, &quot;Error submitting feedback&quot;, e)
                _feedbackResult.emit(Result.failure(e))
            }
        }
    }
}

@Composable
fun FeedbackScreen(viewModel: FeedbackViewModel, navController: NavController) {
    val scope = rememberCoroutineScope()
    val feedbackResult by viewModel.feedbackResult.collectAsState(initial = Result.success(Unit))
    //...

    LaunchedEffect(key1 = Unit) {
        scope.launch {
            viewModel.feedbackResult.collect {
                when(it){
                   is Result.Success -&gt; { }
                   is Result.Error -&gt;{ }
                }
            }
        }
    }
}
</code></pre>
<p>In this example, the <code>feedbackResult</code> is a <code>SharedFlow</code> that emits the result of the feedback submission. The composable collects from this flow and updates the UI accordingly. This decouples the UI updates from the coroutine, making the code more robust to cancellation.</p>
<p><strong>Consider using <code>produceState</code> or <code>LaunchedEffect</code> with a lifecycle-aware scope</strong> for operations that need to survive configuration changes but should be cancelled when the screen is no longer visible. These mechanisms provide a way to tie coroutines to the lifecycle of a composable, ensuring that they are automatically cancelled when the composable is destroyed.</p>
<p>Furthermore, <strong>careful testing</strong> is essential to uncover these race conditions. Try navigating away from screens while background operations are in progress. Simulate slow network connections to increase the likelihood of cancellation. Use tools like the Android Profiler to monitor coroutine activity and identify potential issues.</p>
<p>Finally, remember that <strong>prevention is better than cure</strong>. When designing your application, think carefully about the potential for race conditions and choose your coroutine scopes and cancellation strategies accordingly. A little planning upfront can save you a lot of headaches down the road.</p>
<p>By adopting these strategies, you can significantly reduce the risk of race conditions in your Jetpack Compose applications and create a smoother, more reliable user experience. It's all about understanding the interplay between coroutines, lifecycles, and navigation, and taking a proactive approach to managing these interactions.</p>
<h2>Conclusion: Navigating the Coroutine Landscape in Compose</h2>
<p>Alright, guys, we've covered a lot of ground! We've explored the potential for race conditions when using <code>ViewModelScope</code> in Jetpack Compose with navigation, especially when dealing with <code>onClick</code> lambdas and background operations. We've seen how these race conditions can manifest in real-world scenarios, and we've discussed a range of solutions and best practices to mitigate these issues.</p>
<p>The key takeaway here is that building robust Android applications with Jetpack Compose requires a deep understanding of coroutines, lifecycles, and navigation. It's not enough to simply launch a coroutine and hope for the best. We need to be mindful of the potential for cancellation and design our code to handle it gracefully.</p>
<p>Remember, the strategies we've discussed â€“ using <code>withContext(NonCancellable)</code> for critical sections, handling <code>CancellationException</code> appropriately, decoupling UI updates, using lifecycle-aware coroutine scopes, and careful testing â€“ are all tools in your arsenal for building resilient applications.</p>
<p>As you continue your journey with Jetpack Compose, keep these concepts in mind. Think critically about how your coroutines interact with navigation events and how you can ensure that your application behaves predictably, even in the face of unexpected user actions.</p>
<p>By embracing these best practices, you'll not only avoid frustrating race conditions but also create a better overall experience for your users. Happy coding, and may your coroutines always run smoothly!</p>

                    </div>
                    <aside class="related-posts">
                        <div class="ad-sidebar container">
                            <!-- <div class="ad-wrapper">
    <span>Iklan Related</span>
</div> -->
                        </div>
                        <h2 class="related-posts-title">Related Posts</h2><article class="related-post">
                            <h3 class="related-post-title">
                                <a href="https://catatansoal.github.io/blog/identifying-the-parent-function-of">Identifying The Parent Function Of F(x) = -|x| + 2</a>
                            </h3>
                            <div class="meta">
                            	<time datetime="2025-07-14T16:46:49+00:00">Jul 14, 2025</time>
		                        <span class="view-count">
									50 views
		                        </span>
                            </div>
                        </article><article class="related-post">
                            <h3 class="related-post-title">
                                <a href="https://catatansoal.github.io/blog/how-to-use-worry-beads">How To Use Worry Beads: A Step-by-Step Guide</a>
                            </h3>
                            <div class="meta">
                            	<time datetime="2025-08-06T22:25:21+00:00">Aug 6, 2025</time>
		                        <span class="view-count">
									44 views
		                        </span>
                            </div>
                        </article><article class="related-post">
                            <h3 class="related-post-title">
                                <a href="https://catatansoal.github.io/blog/finding-equations-of-parallel-lines">Finding Equations Of Parallel Lines In Slope-Intercept Form</a>
                            </h3>
                            <div class="meta">
                            	<time datetime="2025-07-14T04:31:26+00:00">Jul 14, 2025</time>
		                        <span class="view-count">
									59 views
		                        </span>
                            </div>
                        </article><article class="related-post">
                            <h3 class="related-post-title">
                                <a href="https://catatansoal.github.io/blog/solving-logarithmic-equations-a-deep">Solving Logarithmic Equations A Deep Dive Into Logâ‚†(1/4) And Logâ‚†(2)</a>
                            </h3>
                            <div class="meta">
                            	<time datetime="2025-07-23T04:16:11+00:00">Jul 23, 2025</time>
		                        <span class="view-count">
									68 views
		                        </span>
                            </div>
                        </article><article class="related-post">
                            <h3 class="related-post-title">
                                <a href="https://catatansoal.github.io/blog/resolving-airflow-lineage-backend-performance">Resolving Airflow Lineage Backend Performance Bottlenecks With Large DAG Histories</a>
                            </h3>
                            <div class="meta">
                            	<time datetime="2025-07-14T18:05:23+00:00">Jul 14, 2025</time>
		                        <span class="view-count">
									82 views
		                        </span>
                            </div>
                        </article>
                    </aside>
                    <aside class="related-posts"></aside>
                </div>
            </div>
        </article>
        <a href="#" class="back-to-top" id="backToTop" title="Back to top">
        	<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-bar-up" viewBox="0 0 16 16">
			  <path fill-rule="evenodd" d="M3.646 11.854a.5.5 0 0 0 .708 0L8 8.207l3.646 3.647a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 0 0 0 .708M2.4 5.2c0 .22.18.4.4.4h10.4a.4.4 0 0 0 0-.8H2.8a.4.4 0 0 0-.4.4"/>
			</svg>
		</a>
    </main>
    <footer class="footer">
        <div class="container">
            <p>Â© 2025 Question Notes</p>
        </div>
    </footer>
    <script>
    	(() => {
            const navToggle = document.querySelector('.nav-toggle');
            const navMenu = document.querySelector('.nav-menu');
            const toggleMenu = () => {
                navMenu.classList.toggle('nav-menu-active');
                navToggle.classList.toggle('nav-toggle-active');
            };
            const backToTopHandler = (e) => {
                e.preventDefault();
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };
            navToggle.addEventListener('click', toggleMenu);
            document.getElementById('backToTop').addEventListener('click', backToTopHandler);
            window.addEventListener('pagehide', () => {
                navToggle.removeEventListener('click', toggleMenu);
                document.getElementById('backToTop').removeEventListener('click', backToTopHandler);
            });
        })();
		(() => {
            window.addEventListener("DOMContentLoaded", (event) => {
                const ellHljs = document.createElement("script");
                ellHljs.setAttribute("src", "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js");
                ellHljs.onload = () => {
                    hljs.highlightAll();
                };
                document.querySelector("body").append(ellHljs);
                const ellFont = document.createElement("link");
                ellFont.setAttribute("href", "https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css");
                ellFont.setAttribute("rel", "stylesheet");
                document.querySelector("head").append(ellFont);
                window.addEventListener('pagehide', () => {
                    // ellHljs.remove();
                    ellFont.remove();
                });

            });
        })();
    </script>
    
    
    
</body>
</html>